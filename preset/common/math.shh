#ifndef PRESET_COMMON_MATH_SHH_
#define PRESET_COMMON_MATH_SHH_

const float kPi = 3.141592653589793;

// Rotates a screen UV coordinate around the origin by `angle`.
vec2 rotate(vec2 screen_uv, float angle) {
  float c = cos(angle);
  float s = sin(angle);

  return vec2(c * screen_uv.x - s * screen_uv.y,
              s * screen_uv.x + c * screen_uv.y);
}

// Converts a normalized screen coordinate to a normalized texture coordinate.
vec2 screen_to_tex(vec2 screen_uv) { return (screen_uv + vec2(1., 1.)) * 0.5; }

// Zooms a screen UV coordinate by displacing it along its axis.
vec2 zoom(vec2 screen_uv, float zoom) { return screen_uv * zoom; }

// Returns the product of two sinusoids with the given coefficients of `arg`.
// Choosing the coefficients such that the number of decimal places required to
// represent their ratio is maximized will give a greater appearance of
// "randomness".
float sin_product(float coeff_a, float coeff_b, float arg) {
  return sin(coeff_a * arg) * sin(coeff_b * arg);
}

float map(float val, float in_low, float in_high, float out_low,
          float out_high) {
  return (val - in_low) / (in_high - in_low) * (out_high - out_low) + out_low;
}

vec4 shift_hue(vec4 color, float hue) {
  const vec3 k = vec3(0.57735, 0.57735, 0.57735);
  float cosine_hue = cos(hue);
  return vec4(color.xyz * cosine_hue + cross(k, color.xyz) * sin(hue) +
              k * dot(k, color.xyz) * (1.0 - cosine_hue), color.w);
}

float sin_product_range(float coeff_a, float coeff_b, float min, float max,
                        float arg) {
  return sin_product(coeff_a, coeff_b, arg) * (max - min) + min;
}

#endif  // PRESET_COMMON_MATH_SHH_
