#ifndef PRESET_COMMON_MATH_SHH_
#define PRESET_COMMON_MATH_SHH_

const float kPi = 3.141592653589793;
const float kEpsilon = 1e-6;

// Folds a value in the range [0, 1] a number of times over on the number line.
// E.g., for 2 `folds`:
//
//   1|
//    |    ^
// O  |   / \
// U  |  /   \
// T  | /     \
//    |/       \
//   0+-----------
//    0         1
//       IN
//
// `folds` can be any positive real value ([0, +inf]).
float fold(float value, float folds) {
  float triangle_value = mod(value * folds, 2);
  if (triangle_value < 1) {
    return triangle_value;
  }
  return 2 - triangle_value;
}

float safe_sqrt(float value) {
  if (value < 1) {
    return 1;
  }
  return sqrt(value);
}

vec2 unit_at_angle(float angle) { return vec2(cos(angle), sin(angle)); }

// Rotates a screen UV coordinate around the origin by `angle`.
vec2 rotate(vec2 screen_uv, float angle) {
  float c = cos(angle);
  float s = sin(angle);

  return vec2(c * screen_uv.x - s * screen_uv.y,
              s * screen_uv.x + c * screen_uv.y);
}

float angle(vec2 vec) { return atan(vec.y, vec.x); }

// Converts a normalized screen coordinate to a normalized texture coordinate.
vec2 screen_to_tex(vec2 screen_uv) { return (screen_uv + vec2(1., 1.)) * 0.5; }

// Zooms a screen UV coordinate by displacing it along its axis.
vec2 zoom(vec2 screen_uv, float zoom) { return screen_uv * zoom; }

// Zooms a screen UV coordinate by displacing it along its axis.
vec2 zoom_towards(vec2 screen_uv, float zoom, vec2 target) {
  return (screen_uv - target) * zoom + target;
}

// Returns the product of two sinusoids with the given coefficients of `arg`.
// Choosing the coefficients such that the number of decimal places required to
// represent their ratio is maximized will give a greater appearance of
// "randomness".
float sin_product(float coeff_a, float coeff_b, float arg) {
  return sin(coeff_a * arg) * sin(coeff_b * arg);
}

float map(float val, float in_low, float in_high, float out_low,
          float out_high) {
  return (val - in_low) / (in_high - in_low) * (out_high - out_low) + out_low;
}

vec4 shift_hue(vec4 color, float hue) {
  const vec3 k = vec3(0.57735, 0.57735, 0.57735);
  float cosine_hue = cos(hue);
  return vec4(color.xyz * cosine_hue + cross(k, color.xyz) * sin(hue) +
                  k * dot(k, color.xyz) * (1.0 - cosine_hue),
              color.w);
}

vec3 hsv_to_rgb(vec3 c) {
  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

float sin_product_range(float coeff_a, float coeff_b, float min, float max,
                        float arg) {
  return sin_product(coeff_a, coeff_b, arg) * (max - min) + min;
}

// Computes the value of a 50% duty rectangular function with period `period`.
//
// The function has the following waveshape:
//
//        x+ -->
//
// val=1  |     ____
//        |    |    |
//        |----|----|----
//        |____|    |____
// val=-1 |
//
//        ^    ^    ^
//        |    |    |
//       x=0   |    |
//             |    |
// x=period/2 -+    +- x=period
//
float rect(float x, float period) {
  float interp = mod(x, period);
  return (interp > period / 2.0) ? 1.0 : -1.0;
}

vec4 blur_sample_texture(sampler2D tex, vec2 uv, ivec2 tex_size,
                         float blur_pix) {
  vec2 offset = vec2(blur_pix, blur_pix) / tex_size;
  vec2 offset_n = vec2(offset.x, -offset.y);
  return (texture2D(tex, uv + offset) + texture2D(tex, uv - offset) +
          texture2D(tex, uv + offset_n) + texture2D(tex, uv - offset_n)) /
         4.0f;
}

// Warps a UV coordinate by a kaleidoscopic effect.
vec2 uv_warp_kaleidoscope(vec2 uv, int num_divisions) {
  float uv_angle = angle(uv);
  float magnitude = length(uv);

  float fragment_angle = mod(uv_angle, kPi / num_divisions);

  if (fragment_angle > kPi / (num_divisions * 2)) {
    fragment_angle = (kPi / num_divisions) - fragment_angle;
  }
  return unit_at_angle(fragment_angle) * magnitude;
}

// Warps a UV coordinate by a spiral-bending effect.
vec2 uv_warp_spiral(vec2 uv, float aspect_ratio) {
  return rotate(uv, length(uv) * aspect_ratio);
}

// Warps a UV coordinate by a fisheye effect.
vec2 uv_warp_fisheye(vec2 uv, float fisheye_coeff) {
  return uv * mix(1, length(uv), fisheye_coeff);
}

// Warps a UV coordinate by folding it over itself a number of times.
vec2 uv_warp_fold(vec2 uv, vec2 center, vec2 folds) {
  return vec2(fold(abs(uv.x - center.x), folds.x),
              fold(abs(uv.y - center.y), folds.y));
}

// Limits the minimum magnitude of a value. Limit policy is selectable with the
// `policy` argument. The sign of the return value is the same as `value`.
const int kLimitMinMagnitudePolicy_Absolute = 0;
const int kLimitMinMagnitudePolicy_Rolloff = 1;
float limit_min_magnitude(float value, float minimum_magnitude, int policy) {
  float scale = abs(value / minimum_magnitude);

  if (policy == kLimitMinMagnitudePolicy_Absolute) {
    if (scale > 1) {
      return value;
    } else {
      return value / scale;
    }
  } else if (policy == kLimitMinMagnitudePolicy_Rolloff) {
    const float kRolloffStartScale = 2;
    if (scale > kRolloffStartScale) {
      return value;
    } else if (scale > 1) {
      return value / mix(1, scale, kRolloffStartScale - scale);
    } else {
      return value / scale;
    }
  } else {
    // Unknown policy. Return the minimum magnitude.
    return minimum_magnitude;
  }
}

#endif  // PRESET_COMMON_MATH_SHH_
